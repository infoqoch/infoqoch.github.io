---
layout: post
author: infoqoch
title: java runtime data area의 세부 영역
categories: [java]
tags: [java, jvm]
---

자바를 학습할 때 계속 막히는 부분이 있고, 무시하거나 암기를 하더라도 계속 나와 괴롭히는 부분이 있다. 바로 런타임을 학습할 때이다. 자바의 런타임에는 다양한 영역이 있고, 그 영역들이 관계를 맺으면서 메모리를 형성한다. 그런데 이에 대한 지식이 없는 상태에서, 중간 중간 마다 런타임에 대한 이해를 전제로 하는 내용이 나올 때마다, 해당 내용을 넘기거나 그냥 암기했다. 이제는 그러지 말자는 결심과 함게 런타임을 다시 정리하고 이해하고자 이 글을 작성한다.

런타임이란 자바언어가 .class파일로서 바이트코드로 컴파일된 값을 읽어내고 출력하는 환경을 의미한다. JVM이 런타임을 작동하는 주체가 된다. 
런타임을 위해 호출되고 저장되고 출력되는 영역 중 이야기하고자 하는 영역은 Method, Heap, JVM Stack과 같다. 

1. JVM Stack area
- 스택 영역은 스래드로서 작동한다. main 매서드나 스레드의 선언 등으로 스택이 할당되고 생성되며, 해당 스레드가 종료되면 해당 스택도 종료된다. 그러므로 관련한 변수는 해당 스레드의 생성과 종료에 종속된다.
- 스택은 그것의 이름과 같이 메모리를 아래서부터 위로 쌓는 형식으로 한다. 가장 위의 코드만 동작하고 아래의 코드는 중지된다.
- int a = 3; 으로 선언을 했다가 그 다음에 a = 10;으로 하면 3은 사라지고 10이 덮어써진다. 이런 식으로 새로운 값(push)이 이전의 값을 밀어낸다(pop). 
- 스택에는 기본 타입(primitive data)과 참조 타입을 저장한다. 참조 타입(reference type)은 일종의 주소로서 힙 혹은 메서드 구역의 특정 값을 가리킨다. 
- 그러므로 기본 타입은 스택이 사라지면 같이 삭제가 된다. 같은 스택이라도 층위가 다를 경우 서로 참조할 수 없다. 하지만 참조변수는 주소가 사라진다 하더라도 실제 데이타는 유지가 된다. 

1. Method area
- 매소드 영역은 JVM이 시작할 때 생성되고 종료까지 사라지지 않으며 모든 스레드가 공유하는 영역이다. 클래스, 필드 데이터, 매소드 데이터, static, 생성자 등으로 선언된 맴버 변수와 매서드 등이 포함된다.

3. Heap area
- 객체와 배열이 생성되는 영역이다. 
- 더 이상 스택에서 사용되지 않는다고 판단하면, 쓰레기 수집기(Garbage Collector)가 삭제한다.  


### 사설

- (솔직히!) 지금 작성하는 내용은 정확한 이해가 아닐 수도 있다. 실수를 용납하지 않는 엄밀한 설명이란 인용, 복사 붙여넣기를 통해 해소 가능하다. 그러나 인용으로 퉁 치면 내가 JVM에 대하여 잘 이해할 수 없을 것 같다. 그런데 누군가가 JVM의 메모리 영역에 대하여 이를 일종의 작업 책상으로 비유했다. 이러한 비유는 나의 이해를 크게 도왔다. 만약 그런 식으로 JVM을 가볍게 생각한다면,
- 컴파일이란 일종의 작업구상을 하고 필요한 자료와 책, 그리고 필요한 인력을 딱 모은 상태라고 볼 수 있을 것 같다. 
- 작업이 실행되면(BootStrap) 그 과정에서 도구와 참고자료, 인력 등을 정리하고 꺼내서 Method Area에 넣는다(class load). 그리고 그러한 자원은 동시다발적으로 필요로 하는 영역에 투입하여 작업을 시키고(Thread), 그 영역의 작업이 종료되면 그것의 결과값만을 챙기고 나머지 작업했던 내용은 정리하면 된다. 
- 작업대의 도구들을 자세히 살펴보자. 계산에 필요로 한 숫자나 메모(primitive data type)는 책상 위의 널부러진 종이 위에 쓰고 필요로 한 작업(thread)을 한다. 그리고 해당 작업이 끝나면 책상 위에 있는 종이들은 쓰레기통에 바로 버린다(stack area). 하지만 망치나 계산기와 같은 도구는 공용 도구함(method area)에서 불러와서 사용하며 다 쓰면 버리지 않고 다시 잘 보관한다. 단순한 숫자보다는 좀 더 양이 많고 복잡한 것(object, collection)은 노트를 만들고(new 연산자) 정리하고 따로 책장에 보관해둔다. 그리고 헷갈릴 수 있으니까 어디에 있는지 잘 기억한다(참조변수). 그리고 다른 작업(thread) 에서 해당 노트를 사용할 수도 있으니까 바로 버리진 않는다. 그러나 더는 필요 없다고 판단하면 버린다(GC). 