---
layout: post
author: infoqoch
title: 클린코더스, SOLID
categories: [refactoring]
published: false
tags: [refactoring, java]
---

## The Source Code is the Design
- 엔지니어는 설계도를 만드는 사람이다. 소프트웨어 개발자에게 설계도는 무엇인가?
- 키보드 엔지니어? 키보드의 설계도를 만든다. 실제 키보드 생산은 공장이 한다.
- 소프트웨어 엔지니어? 빌드가 된 바이너리 코드가 생산물이다. 소스코드가 설계도이자 문서이다.
- 건물, 회로, 기계 : 저렴한 설계 비용, 비싼 수정 비용
- 소프트웨어 : 비싼 설계 비용(소스코드 작성), 저렴한 구축 비용(컴파일, 빌드). 
- 소프트웨어는 설계도인 소스코드를 수정하는데 정말로 많은 자원을 필요로 한다. 
- 좋은 설계는 좋은 소스코드를 구현하는 것에 있다. 

## Design Smells
- 나쁜 디자인으로 설계된 코드는 나쁜 냄새를 풍긴다.

### Rigidity 견고함
- 시스템의 의존성이 너무 견고하여 변경하기 어렵다. 
- 테스트와 빌드가 시간이 너무 오래 걸린다. 의존성 등 문제로 인하여 작은 변화로 전체의 변경이 발생한다. 

### Fragility 취약함
- 한 모듈의 수정이 다른 모듈에 영향을 미친다.
- 라디오 버튼을 수정하니까 창문의 동작에 영향을 미친다. 
- 모듈 간 의존성을 제거해야 한다. 

### Immobility 유연하지 않음
- 모듈이 쉽게 추출되지 않고 재사용되지 않는 경우
- 특정 db, 특정 ui에 강하게 의존되어 있음. 
- stuff로의 의존성을 없앤다. 

## Viscosity 점성
- 빌드/테스트, 체크인/체크아웃,머지 등의 비용이 너무 큼. 
- 여러 레이어를 가로지르는 의존성
- 무책임한 용인 : 나쁜 것이나 나빠질 것으로 보이는 것에 대하여 방치

## Needless Complexity 불필요하게 복잡함
- 불필요한 복잡성을 없애야 한다. 
    - 미래를 예측하는 구현 (나중을 상상하는 abstract class 들)
- 현재에 집중해라. 다만 변경에 대하여 유연할 수 있도록 한다 -> 테스트코드!
- 테스트코드에 집중하여 개발하자.
- 현재에 집중하고, 좋은 코드를 구현하기 위하여 리팩토링을 하다보면 코드의 디자인이 자연스럽게 만들어진다. 나도 모르게(emergent) 코드가 진화한다. 

## Code Rot
- 시간이 흐르며...
    - 요구사항이 늘어나고, 리팩터링과 디자인에 대한 고민 없이 요구사항을 덕지 덕지 붙여넣고, 코드는 복잡해지고... 
    - 어느 순간 코드를 건들고 싶지 않다. 
- OOP로 하였다면?  
    - 기존의 코드는 유지되는데
    - 객체 하나만 구현하고 의존성을 수정하면 된다. 
- 특정 클래스에 다양한 요구사항에 따른 분기가 발생한다 -> 특정 인터페이스를 구현하고, 이를 요구사항에 따른 의존성을 추가할 뿐이다. 
- Copy {switch case(keyboard)...case()}
- Copy - File(input, output) - DI(Keyboard IO Driver, Mouse IO Driver)

## What is OO?
- `o.f(x)` != `f(o, x)`
- OO는 메시지만 전달한다. 어떻게 동작하는지, 무엇을 원하는지 알 수 없다. 
- DI는 OO의 정수
- OO는 IoC를 통해 상위 레벨의 모듈이 하위 레벨의 모듈로부터 보호받는 것. 이것이 객체지향의 핵심.
- OOD란? Dependency 를 잘 관리하는 것. isolation이 제일 중요하다.
- SOLID란 OOP를 위한 중요한 규칙.