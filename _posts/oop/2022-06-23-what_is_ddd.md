---
layout: post
author: infoqoch
title: DDD Start! 도메인 주도 개발 시작하기 읽기
categories: [oop]
tags: [oop, ddd]
---

# 들어가며
- TDD, 리팩터링 등 OOP를 위한 다양한 패러다임을 학습하고 익히면서 도메인 주도 개발에 대한 욕구가 생겼다. 
- 최범균 개발자님의 "테스트 주도 개발 시작하기"를 잘 읽었었다. 이번 신규 서적인 "도메인 주도 개발 시작하기: DDD 핵심 개념 정리부터 구현까지" 를 읽었다. 
- 백명석 개발자님의 클린코더스, 김영한 개발자님의 인프런 강의 덕분에 책의 많은 내용을 이해할 수 있었다. 조금씩 발전하고 있다.
- 아래 정리한 내용은 내가 이해하고 실무에 적용할만한 부분들에 대하여 간단하게 정리하였다. 

# 도메인 주도 개발과 도메인
- 도메인이란 개발자가 해결해야하는 일종의 문제 영역이다. 
- 도메인은 작은 도메인으로 나뉜다. 쇼핑몰을 만드는 개발자에게 있어서, 주문, 배송, 회원, 할인 등 하위 문제 영역이 존재한다. 
- 도메인 주도 개발은 이러한 문제 영역을 분리하고 문제 영역을 기반으로 구현하는 프로그래밍을 의미한다. 

# OCP(단일책임원칙)와 도메인 개발에서의 원칙들
- OCP(단일책임원칙)은 도메인에도 적용된다. 하나의 도메인은 그것에 대하여 홀로 온전하게 책임져야 한다. 예를 들면 주문 기능은 주문 도메인만이 온전하게 가진다. 
- 도메인의 책임의 범위는 넓다. 비지니스 로직, DB와 테이블, 도메인을 이루는 데이터와 객체 관리 등, 그 모든 것을 도메인이 관리해야 한다. 
- 이러한 도메인의 총괄은 애그리거트(루트 엔티티)가 수행한다. 
- 그렇다고 모든 로직을 루트 엔티티가 독점하거나 부담하는 것은 아니다. 루트 엔티티를 이루는 데이터 덩어리로서의 벨류(Value, VO)가, 그 내부에서 로직을 처리하기 위한 기능을 가질 수 있다. 단일책임원칙은 하나의 도메인 내부에서도 지켜져야 한다. 벨류는 자기 자신의 OCP를 마찬가지로 지켜야 한다. 이때 루트 엔티티는 이러한 도메인 내부의 흐름을 통제하는 역할을 한다. 
- Entity와 Value는 분리된다. 엔티티의 중요한 특징은 식별값이 존재하는 것이며 벨류는 이와 달리 단순한 정보의 조합만을 가진다. 
- Value를 적극적으로 활용한다. 기본 타입을 특정 객체로 감싸는 것도 좋은 방법이다. 예를 들면 long money를 Money money로 감쌀 수 있다. 이럴 경우 `add(money); exchange(DOLLAR);` 등 다양한 기능을 부여할 수 있다. 소박한 내용들을 하나의 벨류로 묶고 적절하게 기능을 분배하는 것이 도메인 주도 개발의 중요한 요소이다. 
- OCP를 지키기 위해서는 setter/getter를 제한하고 불변 객체로 구현해야 한다. 

# DI의 필요성
- OCP를 지키고 도메인 주도 개발을 하기 위해서는 DI를 통한 인터페이스 기반으로 개발해야 한다. 
- DI의 가장 중요한 요소는 관심사 분리이다. 도메인 구현의 중요한 지점은 인프라스트럭쳐를 사용하는 것이 아니라, 인프라스트럭쳐에 요구하는 행위를 인터페이스로 표현하는 행위이다. 이러한 개발을 할 경우 자연스럽게 특정 라이브러리나 코드에 종속되지 않는 개발을 할 수 있다. 

- 예를 들어, 아래와 같이 ABCPrinter을 사용하는 도메인이 있다고 가정하자. 

```java
public class OrderService{
    public void printOrders(){
        ABCPrinter printer = new ABCPrinter(); // 특정 모듈에 의존하는 코드가 작성된다.
        printer.print(args...); // 특정 모듈의 특정 메서드를 사용한다. 기능은 이해하나 의도가 명확하지 않다. 
    }
}
```

- 특정 라이브러리에 종속되었기 때문에 문제가 있다. 그러나 그보다 더 치명적인 문제는 관심사가 명확하지 않다는 점이다. 우리의 관심사는 ABCPrinter란 모듈이 아니다. 
- ABCPrinter를 구현한 후에 OrderService가 동작하며, 이로 인해 OrderService와 Printer를 동시에 개발하는 것이 어려운 것도 문제이다.
- 추가적으로 ABCPrinter를 교체하기 어렵기 때문에 테스트에 불리하다. 

```java
@RequiredArgsConstructor
public class OrderService{
    private final OrderPrinter printer;

    public void printOrders(){
        printer.printOrderListForCustomer(args...); // 고객을 위한 프린터를 하는 것이 명확하게 드러난다.
    }
}
```

- 관심사가 명확해졌다. ABCPrinter의 인터페이스라 하여 ABCPrinterInterface로 이름으로 지어서는 안된다. 상위 객체의 입장에서 그것의 관심사에 맞춰 인터페이스를 구현해야 한다. 
- 인터페이스로 변경하였고 테스트에 유리하다.

## 항상 DI를 적용해야 하는 것은 아니다.
- TDD로 개발하면 자연스럽게 interface를 통해 개발한다.
- 한편, 반드시 필요하지 않은 상황에서 DI로 구현하면 시간을 소비하고 혼란을 가중시킨다. 
- 예를 들면 인프라스트럭쳐에 명백하게 의존적인 구현체가 존재한다. 이런 경우 굳이 DI로 구현할 필요는 없다. 
- 인터페이스가 과도하게 구현할 경우, 각각의 인터페이스에 대한 구현체가 하나만 있는 상태가 된다. 
- 인터페이스를 사용하지 않더라도 mockito를 적극적으로 활용하면 테스트를 진행할 수 있다. 


# 애그리거트
## 애그리거트란
- 애그리거트란 연관 도메인을 하나로 묶은 것이다. 
- 엔티티와 밸류보다 더 큰 개념으로서 세세한 내용보다 전체적인 그림을 그릴 때 활용한다. 특히 다양한 테이블로 구성된 ERD를 묶는 경계로서 사용한다. 
- 애그리거트는 대체로 하나의 엔티티를 가지며 이를 루트 엔티티라고 한다. 루트 엔티티는 애그리거트의 일종의 대리인 역할을 하며, 해당 애그리거트가 요구하는 로직을 수행한다. 
- 애그리거트에 소속된 값들은 동일한 라이프사이클을 가진다. 루트 엔티티에 속한 밸류들은 루트 엔티티와 함께 조회되고 저장되고 변경된다. 
- 애그리거트는 자신의 애그리거트만을 관리한다. 
- 애그리거트의 부분이 변경되면 전체가 변경될 수 있다. 주문한 상품이 변경되면 주문 가격이 변경되고 결제를 다시 해야할 수 있다. 이러한 문제를 최소화하기 위해서는 루트 엔티티가 벨류를 관리해야 한다.
- 자주 동시에 함께 사용된다고 하여 같은 애그리거트라고 확정할 수 없다. 상품의 주문 후 상품 리뷰가 이뤄진다고 하여, 주문과 리뷰가 같은 애그리거트는 아니다.

## 좋은 애그리거트의 특징
- 애그리거트의 내부를 외부에서 변경할 수 없다. 반드시 애그리거트를 통해 수정한다. 
- 트랜잭션 하나에 애그리거트 하나만 존재하는 것이 이상적이다. 만약 두 개를 동시에 처리해야 한다면 응용 서비스단에서 처리해야 하며, 도메인 내부로 가져와서는 안된다. 

## 루트 엔티티의 객체 탐색
- JPA를 기준으로 루트 엔티티가 하위 도메인이나 벨류에 참조하는 방법은 크게 두 가지이다.
    - 객체
    - pk

### 객체를 통한 탐색 
- 객체를 필드로 가진 루트 엔티티는 객체를 쉽게 탐색할 수 있다. DB를 쉽게 쿼리한다. 지연로딩의 편의성을 적극적으로 활용할 수 있다. 
- 객체 그래프는 오용의 여지가 있다. 객체는 자신의 필드를 드러내서는 안된다. 더티체킹으로 인한 데이터가 오염 가능성이 존재한다.

```java
public class Order{
    Member orderer(){        
        return member;
    }
}

public void static main(String[] args){
    Member member = order.orderer();
}
```

### PK를 통한 탐색 
- PK를 통해 탐색하면, 필요에 따라 리포지토리를 다른 기술로 구현할 수 있다. Order는 MariaDB로 사용하고 OrderLine은 몽고 DB를 사용하는 형태이다. 

## 팩토리를 활용하여 객체 탐색을 우회
- 특정 로직을 수행하기 위해서는 여러 개의 애그리거트를 필요로 할 수 있다. 특정 주문을 위하여 주문자의 회원 정보를 조회할 경우, 주문과 회원 두 개의 애그리거트가 필요하다. 
- 한편, 주문의 입장에서 회원은 주문자로서 주문 도메인의 필드 중 하나이다. 내부의 객체를 애그리거트 밖으로 꺼내는 것은 좋은 방법이 아니다.
- 예를 들면, 더 이상 상품 주문을 허용하지 않는 회원이 있다고 가정하고, 해당 회원이 주문할 때 예외를 발생시키는 로직이 있다고 하자.

```java
public void order(...args){
    Member member = order.member();
    if(member.isBlocked())
        throw new SomeException();
    Order order = Order.newOrder(args...);
    // 후략...
}
```

- 위의 코드는 Member가 해당 비지니스 로직에 노출되어 버린다. 이보다는 아래와 같이 애그리거트 내부에 해당 로직을 구현하는 것이 낫다. 이때 팩토리를 사용한다.

```java
public void order(...){
    Order order = Order.newOrder(args...);
}

public class Order{
    public statis Order newOrder(Member member, Object... args){
        if(member.isBlocked())
            throw new SomeException();
        // 후략...
    }
}
```

# 응용 서비스의 구현
## 로직은 도메인에
- 도메인과 관련한 로직은 도메인이 부담한다. 
- 도메인에 로직이 잘 배치될 경우, 응용 서비스는 단순한 흐름을 가지게 된다.

## 서비스의 크기
- 응용 서비스가 크면 공통 로직을 활용하기 좋음. 
- 응용 서비스가 작으면 관리하기 쉬움. 필요한 의존성만 주입할 수 있음.
- 권장하는 public 메서드의 갯수는 1 - 3개.
- 응용 서비스의 공통로직은 static method 를 활용.

# 표현영역
- 사용자나 외부 API와 연결되는 영역
- 응용 서비스의 데이터를 적절한 형태로 변환하여 전달하는 역할을 한다.

## 데이터 검증
- 데이터 검증의 위치는 표현영역과 응용 서비스에서 대체로 처리한다.
- 응용 서비스는 데이터는 검증을 책임진다. 응용 서비스가 검증의 범위가 넓으면 넓을 수록 공통 기능을 구현할 수 있어 완성도 있는 도메인을 구현하게 된다. 
- 다만, 스프링의 경우 표현영역인 컨트롤러를 통해 데이터 검증을 하는 것이 쉽고 수월하다. 
    - BindingResult 등 검증을 위한 훌륭한 기능을 컨트롤러의 인자로 받을 수 있다.
    - 서비스는 예외를 통해서 단 하나의 오류를 전달하지만, 컨트롤러는 BindingResult를 통해 다수의 오류를 전달할 수 있다. 
- ValidationError을 서비스는 이러한 한계를 극복할 수 있다. 

# CQS
- 도메인이 항상 도메인이 아니다. 회원 도메인에서 회원은 루트 엔티티이지만, 주문에서의 주문자는 벨류로서 동작한다. 
- 커맨드와 쿼리의 분리는 이렇게 엔티티와 벨류로서 분리되는 경우 사용되는 개념이다. 
    - 도메인이 자신의 데이터를 갱신하는 경우 커맨드에서 관리한다. 
    - 단순한 조회를 하거나 다른 애그리거트의 커맨드를 위한 정보 제공으로서 데이터를 전달할 수 있다. 이 경우 벨류로서 동작한다. 
- 커맨드와 쿼리의 분리는 다양한 차원으로 수행할 수 있다. 
    - 단순하게 패키지만 분리하고 쿼리를 위한 리포지토리를 구현할 수 있다. 
    - 아예 분리할 수 있다. 도메인은 JPA로 구현하고 쿼리는 JDBC Template으로 구현할 수 있다. 후자의 경우 대체로 DAO, DTO 등의 이름을 사용한다. 