---
layout: post
author: infoqoch
title: db, lock에 대하여
categories: [db]
tags: [db, mysql]
---

## Share lock, S lock
- 하나의 로우에 대한 락을 여러 트랜잭션이 소유할 수 있다. select에 대해서는 자유롭다. 
- 다만 두 개 이상의 트랜잭션이 s lock을 가진 상태에서 그 누구도 해당 레코드에 대해 x lock을 가질 수 없다. 데이터에 대한 갱신을 할 수 없다.
- `lock in share mode`, `for share` 을 select 쿼리에 붙이면 된다. 
- SERIALIZABLE의 모든 select 쿼리는 for share 가 붙는다.

## Exclusive lock, X lock
- 동일한 레코드에 대하여 다수의 트랜잭션이 락을 소유하고 select할 수 있었던 S lock과 달리, select 그 자체도 트랜잭션 하나만 유일하게 소유한다. 그러니까 `select ... for update`를 호출할 수 있는 트랜잭션은 단 하나이다.
 
```sql
-- 공통 REPEATABLE READ;  

-- record lock  테스트
-- 트랜잭션 A 
SELECT * FROM TESTS WHERE id = 'a1' FOR share; 

-- 트랜잭션 B 1차
UPDATE tests SET name = 'record_lock_kim' WHERE id = 'a1'; -- 교착상태. lock이 걸린 상태에서 write는 불가능.

-- 트랜잭션 B 1차
UPDATE tests SET name = 'record_lock_kim2' WHERE id = 'a2'; -- 가능
```

## Intention lock IX, IS
- Table-level lock
- X lock과 S lock이 걸리면 해당 테이블에 각각 IX, IS 락을 건다. 
- IX, IS은 여러 트랜잭션이 가질 수 있다. 
- 테이블의 변경을 block한다. alter table, drop table 등을 사용할 수 없다. 테이블의 변경이 일어날 때, 그 누구도 IX, IS락을 가질 수 없다. 

## gap lock, range lock
- lock이 하나의 레코드, 로우가 아닌 범위에 걸린다. 
- 해당 범위에 대해서는 다른 트랜잭션에서 갱신이 불가능하다. 데이터의 정합성을 보장하며 phantom read를 완전하게 방지한다. REPEATABLE READ에서 사용된다.
- READ COMMITTED은 NON-REPEATABLE-READ이므로 갭락을 지원하지 않는다. select을 범위로 지정한다 하더라도 각각의 레코드에 대해서만 락을 획득할 뿐이다. 그러니까 pk, uk 등을 위배하지 않는 한 어디든 insert 가능하다. 
- 갭락의 범위는 index의 존재에 따라 다르게 적용된다. 
    - index가 있을 경우, 해당 데이터를 탐색할 때 사용한 index의 범위에 대해서만 갭락이 걸린다.
    - index가 적용되지 않을 경우, 모든 레코드에 락이 걸린다. 범위는 nagative infinity 부터 positive infinity 이며 테이블 자체에 insert가 불가능하다.

```sql
-- select 및 update statement, gap lock

-- share 테스트 
-- 트랜잭션 A 
SELECT * FROM TESTS FOR share; 

-- 트랜잭션 B
SELECT * FROM TESTS; -- 가능 
SELECT * FROM TESTS FOR share;  -- 가능
SELECT * FROM TESTS FOR update;  -- 교착상태. s락을 다수가 가진 상태에서 x락을 얻을 수 없다.
UPDATE tests SET name = 'share_kim' WHERE id = 'a1'; -- 교착상태. lock이 걸린 상태에서 write는 불가능.

-- update 테스트
-- 트랜잭션 A 
SELECT * FROM TESTS FOR update;

-- 트랜잭션 B
SELECT * FROM TESTS;  -- 가능
SELECT * FROM TESTS FOR share;  -- 교착상태. x락은 s락을 막는다.
UPDATE tests SET name = 'share_kim' WHERE id = 'a1'; -- 교착상태. lock이 걸린 상태에서 write는 불가능.
```

### gap lock 의 필요성
- gap lock이 존재할 경우, 데이타 갱신에서의 정합성을 확보할 수 있다. 
- 트랜잭션 1과 2가 동시에 동시에 동작 중이며 주석(--)이 있는 트랜잭션은 트랜잭션 2이다.

```sql
-- READ COMMITED

select * from tb for share; -- 내부 로직으로 Van Gogh의 작품이 10~20에 있음을 확인한다.
-- insert into tb values(15, 'Lautrec'); -- 어떤 트랜잭션이 갑자기 데이터를 삽입한다.
udpate tb set printer = 'Van Gogh' where seq between 10 and 20; -- 15가 Van Gogh로 오변경 된다. 


-- REPEATABLE READ

select * from tb for share;
-- insert into tb values(15, 'Lautrec'); -- 교착상태. insert 자체가 불가능하다. 데드락으로 db가 인식하고 세션이 kill 된다.
udpate tb set printer = 'Van Gogh' where seq between 10 and 20; -- 첫 번째 쿼리가 DB의 가장 최신의 상태이며, 기대하는 대로 동작한다. 
```

## Next-Key Lock
- record lock과 gap lock이 동시에 걸린 복잡한 상태를 의미한다.
- 락이 걸린 범위에서의 record는 record lock이 걸리고 나머지에 대해서는 gap lock이 발생한다.
- select * from test where seq > 10; 이며 데이터는 2, 5, 6, 8, 12 이 있다고 가정하면,
    - 2, 5, 6, 8은 각각 record lock이 걸린다.
    - negative infinity < gap lock < 12 까지 gap lock이 걸린다. 

## Insert Intention Lock
- insert 구문을 사용할 때 암묵적(implicit)으로 획득하는 gap lock. 
- Insert Intention Lock -> X lock (record) 순서로 락이 걸린다. Insert Intention Lock은 같은 범위 내에서 다중 발행된다.
    - 기존의 gap lock을 사용할 경우 : 
        - tx1 : insert seq = 10 시도 -> 비어있는 5 - 15 까지 gap lock이 발생한다.
        - tx2 : insert seq = 11 시도 -> gap lock 이 해방 되기를 기다린다. 
    - Insert Intention Lock을 사용할 경우 
        - tx1 : insert seq = 10 시도 -> 비어있는 5 - 15 까지 Insert Intention Lock 이 발생한다.
        - tx2 : insert seq = 11 시도 -> Insert Intention Lock 을 공동 소유하며 insert는 특별한 문제 없이 수행된다. 

## AUTO-INC Lock
- 시퀀스 자동 생성과 관련한 락

## DB의 정합성을 고려한 개발
- 앞서의 내용을 학습하는 이유는 안전하게 DB를 다루고 싶고, 성능 문제를 해소하고 데드락을 원천적으로 제거하여 서버의 성능이나 클라이언트의 사용성을 좋게 하기 위해서이다. 이러한 이유로 이번 블로그와 더불어 이전 블로그에서 트랜잭션을 학습하고 정리하였다. 실무에 대한 고민이 많았다. 

### 커넥션, 트랜잭션은 롤백을 공유하지 않는다.
- 예외 상황에서 트랜잭션은 롤백을 통하여 문제를 해소한다. all or nothing.
- 하지만 다른 커넥션이나 이미 커밋된 트랜잭션에 대하여 롤백을 제공하지는 않는다. 
- 외부 API 역시 마찬가지이다. 외부 API에게 성공으로 보냈는데 그 이후 로직에서 실패했다고 하여 이미 보낸 통신을 취소할 수는 없다. 
- 롤백의 가능 범위를 이해해야 한다. 데이터를 갱신하지만 롤백이 예외를 통해 쉽게 적용되지 않는 경우에 대해서는 최대한 해당 로직의 마지막에 배치하는 것이 낫다. catch에 롤백을 위한 기능을 추가해야할 수도 있다. 

### 명시적 잠금
- `select .... for update` 등을 사용하여 락을 획득한다.

### 원자적 연산 사용
- update를 할 때 원자적 연산(+=)을 사용하는 것이 무결성에 더 낫다.

```sql
select hit from test; -- hit : 1
update TEST set hit = 2 where ....; 
update TEST set hit += 1 where ....; 
```

### CAS ( compare and set)
- 레코드에 버전을 부여하고, 갱신할 때 해당 버전을 항상 사용한다.

```sql
select * from test where no = '1'; -- ver가 1임을 확인했다.

update test
set ver = 2, name = 'kim' 
where no = '1' and ver='1'
```

> https://www.letmecompile.com/mysql-innodb-lock-deadlock/

> https://www.slideshare.net/billkarwin/innodb-locking-explained-with-stick-figures

> https://www.youtube.com/watch?v=poyjLx-LOEU


## x 락은 동일한 select 쿼리에 대하여 배타적인 권한을 주는 것은 아니다.
- x 락은 조회에 대하여 배타적인 권리를 가진다. 
- 이러한 효과는 나로서는 DB차원에서 트랜잭션을 동기적으로 하나씩 처리할 수 있는 효과를 줄 것이라 기대했다. 복제된 다수의 어플리케이션과 다수의 쓰레드가 하나의 DB를 사용하는 상황에서, 동기적 처리가 필요한 순간은 있기 때문이다. 
- 하지만 내가 기대한 것처럼 동작하지 않았다. 

### for update는 select을 막지 못했다. 
- 아래의 쿼리로 for update를 테스트하였다.
- 주석(--)이 없는 것은 트랜잭션 A, 있는 것은 트랜잭션 B이다.
- 격리수준은 항상 REPEATABLE READ 이다.

```sql
-- 테스트 1.1. 전체 검색
SELECT * FROM TESTS FOR update; 
-- SELECT * FROM TESTS FOR update; -- 교착

-- 테스트 1.2. 전체 카운트
SELECT count(*) FROM TESTS FOR update;
-- SELECT count(*) FROM TESTS FOR update; -- 교착
```

- 위의 테스트를 진행하면 전체 탐색에 대해서는 교착이 발생함을 확인할 수 있다. 

- 아래의 코드 중 seq는 auto increment가 되는 pk 이다. index가 있다. 100까지 데이터가 있다.

```sql
-- 테스트 2. 
EXPLAIN SELECT count(1) FROM TESTS WHERE SEQ  = 1 ; -- index
EXPLAIN SELECT count(1) FROM TESTS WHERE SEQ  = 130 ; -- no matching row in const table
EXPLAIN SELECT count(1) FROM TESTS WHERE SEQ  = 150 ; -- no matching row in const table

-- 테스트 2.1. index가 걸린 칼럼의 레코드를 검색했고 그 레코드가 존재한다. 
SELECT count(1) FROM TESTS WHERE SEQ  = 1 FOR UPDATE; -- 존재한다.

-- SELECT count(1) FROM TESTS WHERE SEQ  = 1 FOR UPDATE; -- 교착
-- SELECT count(1) FROM TESTS WHERE SEQ  = 2 FOR UPDATE; -- 정상

-- INSERT INTO TESTS (SEQ , ID, NAME) VALUES ('1', '130 ID', '130 name') -- 교착
-- INSERT INTO TESTS (SEQ , ID, NAME) VALUES ('2', '130 ID', '130 name') -- 정상. 그러나 duplicate entry로 예외 발생
-- INSERT INTO TESTS (SEQ , ID, NAME) VALUES ('130', '130 ID', '130 name') -- 정상
-- INSERT INTO TESTS (SEQ , ID, NAME) VALUES ('150', '150 ID', '130 name') -- 정상 
```

- 인덱스가 있고, 그 값이 존재하면, 그 이외의 레코드에는 락이 걸리지 않는다. 현 상황에서는 seq = 1에 대해서만 record lock이 걸린다.

```sql
-- 테스트 2.2. index가 걸린 칼럼의 레코드를 검색했고, 그 레코드는 없다. 
SELECT count(1) FROM TESTS WHERE SEQ = 150 FOR UPDATE; -- 150은 없음.

-- SELECT count(1) FROM TESTS WHERE SEQ  = 1 FOR UPDATE; -- 정상
-- SELECT count(1) FROM TESTS WHERE SEQ  = 150 FOR UPDATE; -- 정상
-- INSERT INTO TESTS (SEQ , ID, NAME) VALUES ('130', '130 ID', '234982374 name') -- 교착 : 130은 없음
-- INSERT INTO TESTS (SEQ , ID, NAME) VALUES ('150', '150 ID', '234982374 name') -- 교착 : 150은 없음
```

- 앞서의 내용과 달리, 레코드가 없을 경우, 기대하는 것처럼 select에 대하여 배타적인 권한을 얻지 못했다. 
- 그러므로 동일한 select 쿼리 `SELECT count(1) FROM TESTS WHERE SEQ = 150 FOR UPDATE;` 를 두 개의 트랜잭션에서 할 수 있었다. 
- 결과적으로 x 락을 통해 select 자체에 대한 유일한 트랜잭션의 락을 완전하기 기대할 수 없게 된다. 
- 결국 s 락을 가지는 것과 동일하게 insert에서 교착상태가 되어 버린다. 

- 아래의 블로그 발췌글이나 다른 블로그를 보면 레코드가 하나 이상 검색됨을 전제함을 확인할 수 있다. 
> 컬럼에 대한 WHERE 절로 많은 row들을 제외시키고 하나의 레코드만 추출되었을때, Record lock과 Gap lock 어느것이 사용될까?
> > 컬럼에 unique index가 걸려있는 경우에는 gap lock이 필요없다. (record lock이 사용됨)
> > 컬럼에 index가 걸려있지 않거나, index가 걸려있어도 unique 하지 않다면 gap lock이 필요하다.
> > index가 걸려있다면 row를 찾기위해 스캔했던 index range에 대해서 gap lock 적용
> > index가 걸려있지 않다면 결국 테이블 전체를 스캔해야 되기때문에 모든 row에대해 lock이 걸림.